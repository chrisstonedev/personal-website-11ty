---
title: 'Deploy Without Fear Using Automated Tests'
description: A conference talk about the usefulness of different types of automated tests.
layout: reveal.njk
---

<section>
	<h1 class="r-fit-text">Deploy Without Fear<br />Using Automated Tests</h1>
	<div
		style="display: grid; grid-template-columns: 2fr 1fr; align-items: center"
	>
		<p>Chris Stone<br /><a href="/">https://chrisstone.dev</a></p>
		<a href="/deploy-without-fear"
			><img
				src="/img/deploy-without-fear-2d-code.svg"
				alt="QR code for talk notes and slides"
		/></a>
	</div>
	<aside class="notes">
		Hello everyone! Thank you for coming to my talk. I'm Chris, and I'm going to
		talk about automated tests, and I'm going to talk about fear. If you go to
		chrisstone.dev or scan this QR code, you can get talk notes and the slides.
	</aside>
</section>
<section
	data-background="/img/deploy-without-fear-slides-sponsor-slide.png"
	data-background-size="contain"
>
	<aside class="notes">
		I am happy to be here at Atlanta Cloud Conference, and I want to express my
		gratitude to the organizers, the sponsors, the volunteers, my fellow
		speakers, and everyone who came out today.
	</aside>
</section>
<section>
	<h2>My goals today</h2>
	<ul>
		<li>Share lessons learned adding automated testing on various teams</li>
		<li>Show my appreciation of automated tests and what they can do for us</li>
		<li>Teach some basics of types of tests</li>
		<li>Inspire people here to write some great tests</li>
	</ul>
	<aside class="notes">My goals today...</aside>
</section>
<section>
	<h2>Why don't people write tests?</h2>
	<ul>
		<li>Not sure what to test</li>
		<li>Not sure what a "good test" looks like</li>
		<li>Someone else is in charge of the tests</li>
	</ul>
	<aside class="notes">
		...and while I can't answer these questions on behalf of your team, I hope
		that I can inspire you to think critically about some of these and maybe
		even gain some energy to fight for some good patterns. Also...
	</aside>
</section>
<section data-auto-animate>
	<h2>Why do I write tests?</h2>
	<ul>
		<li class="fragment" data-fragment-index="0">I get scared 😭</li>
		<li class="fragment">I see code I don't understand</li>
		<li class="fragment">I'm worried the deployment had problems</li>
	</ul>
	<img
		class="fragment"
		data-fragment-index="0"
		src="/img/deploy-without-fear-slides-im-scared.png"
		alt="I don't know what any of this is and I'm scared"
	/>
	<aside class="notes">
		So why do I write tests? ...and while I can't answer these questions on
		behalf of your team, I hope that I can inspire you to think critically about
		some of these and maybe even gain some energy to fight for some good
		patterns.
	</aside>
</section>
<section data-auto-animate>
	<h2>Dealing with fear</h2>
	<blockquote style="width: 100%; font-size: 22pt">
		I must not fear. Fear is the mind-killer. Fear is the little-death that
		brings total obliteration. I will face my fear. I will permit it to pass
		over me and through me. And when it has gone past I will turn the inner eye
		to see its path. Where the fear has gone there will be nothing. Only I will
		remain.
	</blockquote>
	<figure
		style="
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 2em;
			justify-items: center;
			align-items: center;
		"
	>
		<img
			src="/img/deploy-without-fear-slides-dune.jpg"
			alt="Dune by Frank Herbert"
			style="height: 300px"
		/>
		<figcaption><em>Dune</em> by Frank Herbert</figcaption>
	</figure>
	<aside class="notes">
		There are a couple of books that tackle dealing with this kind of fear. In
		Dune, it is said, "I must not fear. Fear is the mind-killer." In other
		words, this too shall pass, so let's face the fear and understand that
		things will be OK eventually. For my specific fear, though, we can do better
		than that.
	</aside>
</section>
<section data-auto-animate>
	<h2>Dealing with fear</h2>
	<blockquote data-id="transformQuote">
		Test until fear is transformed into boredom.
	</blockquote>
	<figure
		style="
			display: grid;
			grid-template-columns: 1fr 1fr;
			justify-items: center;
			align-items: center;
		"
	>
		<img
			src="/img/deploy-without-fear-slides-tdd-by-example.jpg"
			alt="Test-Driven Development by Example by Kent Beck"
			style="height: 400px"
		/>
		<figcaption>
			<em>Test-Driven Development<br />By Example</em><br />by Kent Beck
		</figcaption>
	</figure>
	<aside class="notes"></aside>
</section>
<section data-auto-animate>
	<h2>Dealing with fear</h2>
	<blockquote data-id="transformQuote">
		Test until fear is transformed into boredom.
	</blockquote>
	<p class="fragment">
		If something in our application scares me,<br />that's where I write a test.
	</p>
	<p class="fragment">
		If I don't worry about something not working,<br />then I don't worry about
		testing any further.
	</p>
	<aside class="notes">
		<p>
			I think about this quote whenever I am asked where we should start writing
			tests or where the bounds of our testing should be.
		</p>
		<ul>
			<li>
				If something in our application scares me, that's where I write a test.
			</li>
		</ul>
		<ul>
			<li>
				If I don't worry about something not working, then I don't worry about
				testing any further. This is overgeneralizing what is honestly a
				difficult problem of how and why to write tests, but I really like this
				as a starting point, and I'll show some examples of how I use this on my
				team throughout the talk.
			</li>
		</ul>
	</aside>
</section>
<section data-auto-animate>
	<h2>Why do I write tests?</h2>
	<ul>
		<li>I get scared</li>
		<li class="fragment custom faded">Code coverage</li>
		<li class="fragment custom faded">Regression detection</li>
		<li class="fragment custom faded">Write simple code</li>
		<li class="fragment custom faded">Executable documentation</li>
	</ul>
	<aside class="notes">
		<p>
			Ok, so, back to why I would write tests, there's the desire to test away
			the fears I have with the application, but we can think of a few more
			things too.
		</p>
	</aside>
</section>
<section data-auto-animate>
	<h2>Reasons to test</h2>
	<h3>Code coverage</h3>
	<p>100% is not realistic and not useful.</p>
	<p>You can increase coverage while not testing things of value.</p>
	<aside class="notes">Code coverage</aside>
</section>
<section data-auto-animate>
	<h2>Reasons to test</h2>
	<h3>Regression detection</h3>
	<ul>
		<li>CI/CD</li>
		<li>Address flaky tests, team should have faith in the test suite</li>
	</ul>
	<aside class="notes">Hello</aside>
</section>
<section data-auto-animate>
	<h2>Reasons to test</h2>
	<h3>Write <strike>simple code</strike> (will think about this)</h3>
	<ul>
		<li>TDD</li>
		<li>Tests will help drive simple design to avoid accidental complexity.</li>
	</ul>
	<aside class="notes">Hello</aside>
</section>
<section data-auto-animate>
	<section data-auto-animate>
		<h2>Reasons to test</h2>
		<h3>Executable documentation</h3>
		<h4>Why tests are the best documentation</h4>
		<div style="display: flex">
			<p>Extensive documentation</p>
			<p>Imagine a Confluence screenshot</p>
		</div>
	</section>
	<section data-auto-animate>
		<h2>Reasons to test</h2>
		<h3>Executable documentation</h3>
		<h4>Why tests are the best documentation</h4>
		<pre><code data-id="comment-animation" data-trim data-noescape data-line-numbers class="language-ts">
// add numbers (oh, and replace this example with a better one!)
const x = 1 + 2;
  </code></pre>
		<p>Comments can lie</p>
	</section>
	<section data-auto-animate>
		<h2>Reasons to test</h2>
		<h3>Executable documentation</h3>
		<h4>Why tests are the best documentation</h4>
		<pre><code data-id="comment-animation" data-trim data-noescape data-line-numbers class="language-ts">
// add numbers (oh, and replace this example with a better one!)
const x = '1' + '2';
  </code></pre>
		<p>Comments can lie</p>
	</section>
	<section data-auto-animate>
		<h2>Reasons to test</h2>
		<h3>Executable documentation</h3>
		<h4>Why tests are the best documentation</h4>
		<pre><code data-trim data-noescape data-line-numbers class="language-ts">
// pretend there is a test here
  </code></pre>
		<p>A test will fail if it becomes untrue.</p>
	</section>
	<section data-auto-animate>
		<h2>Reasons to test</h2>
		<h3>Executable documentation</h3>
		<h4>What does it mean for writing to be effective?</h4>
		<ul>
			<li class="fragment custom faded">Readable</li>
			<li class="fragment custom faded">Relevant</li>
			<li class="fragment custom faded">Applicable</li>
		</ul>
		<aside class="notes">
			<p>Hi</p>
			<ul>
				<li>
					For one, tests should be readable. Just like with any code that we
					write, we optimize for readability.
				</li>
				<li>
					For one, tests should be readable. Just like with any code that we
					write, we optimize for readability.
				</li>
				<li>
					For one, tests should be readable. Just like with any code that we
					write, we optimize for readability.
				</li>
			</ul>
		</aside>
	</section>
	<aside class="notes">
		What does it mean to have effective documentation?
	</aside>
</section>
<section data-auto-animate data-auto-animate-restart>
	<blockquote>Test until fear turns into boredom.</blockquote>
	<p>Kent Beck</p>
</section>
<section data-auto-animate data-auto-animate-restart>
	<section data-auto-animate>
		<h2>Types of tests</h2>
		<ul>
			<li>Unit</li>
			<li>Integration</li>
			<li>End-to-end</li>
		</ul>
		<aside class="notes">Hello!z</aside>
	</section>
	<section data-auto-animate>
		<h2>Types of tests</h2>
		<ul>
			<li>
				Unit
				<ul class="fragment grow">
					<li>a</li>
					<li>b</li>
					<li>c</li>
				</ul>
			</li>
			<li>Integration</li>
			<li>End-to-end</li>
		</ul>
		<aside class="notes">Hello!z</aside>
	</section>
	<section data-auto-animate>
		<h2>Types of tests</h2>
		<h3>Which type to pick</h3>
		<div
			style="display: grid; grid-template-columns: 1fr 1fr"
			class="r-stretch"
		>
			<figure class="fragment">
				<img
					src="/img/deploy-without-fear-slides-test-pyramid.png"
					alt="Test Pyramid"
					style="height: 50%"
				/>
				<figcaption>Test Pyramid</figcaption>
			</figure>
			<figure class="fragment">
				<img
					src="/img/deploy-without-fear-slides-test-trophy.jpg"
					alt="Test Pyramid"
					style="height: 50%"
				/>
				<figcaption>Test Trophy</figcaption>
			</figure>
		</div>
		<p class="fragment">Pick the lowest level that gives value.</p>
		<aside class="notes">
			<p>
				you can use any of these tools to test anything, but you may not want to
			</p>
		</aside>
	</section>
	<section data-auto-animate>
		<h3>Which type to pick</h3>
		<pre><code data-trim data-noescape data-line-numbers class="language-ts">
// pretend there is business logic here
  </code></pre>
		<table data-id="test-types-table">
			<thead>
				<tr>
					<th></th>
					<th style="text-align: center">Unit</th>
					<th style="text-align: center">Integration</th>
					<th style="text-align: center">End-to-end</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th>Value</th>
					<td
						class="fragment"
						data-fragment-index="2"
						style="text-align: center"
					>
						✅
					</td>
					<td
						class="fragment"
						data-fragment-index="1"
						style="text-align: center"
					>
						✅
					</td>
					<td
						class="fragment"
						data-fragment-index="0"
						style="text-align: center"
					>
						✅
					</td>
				</tr>
				<tr>
					<th>Effort</th>
					<td
						class="fragment"
						data-fragment-index="2"
						style="text-align: center"
					>
						✅
					</td>
					<td
						class="fragment"
						data-fragment-index="1"
						style="text-align: center"
					>
						✅
					</td>
					<td
						class="fragment"
						data-fragment-index="0"
						style="text-align: center"
					>
						✅
					</td>
				</tr>
			</tbody>
		</table>
		<aside class="notes">
			test that business logic occurs where everything else passes through. we
			can test at all levels, but get all our value from the unit test
		</aside>
	</section>
	<section data-auto-animate>
		<h3>Which type to pick</h3>
		<pre><code data-trim data-noescape data-line-numbers style="height: 300px">
var dbStaticResources []db.StaticResource
query := s.dbClient.
    Model(db.StaticResource{}).
    WithContext(ctx).
    Distinct().
    Select(
       "static_resources.id",
       "static_resources.grade",
       "static_resources.title",
    )

if input != nil {
    if input.ResourceType.IsValid() {
       query = query.Where("static_resource_type = ?", input.ResourceType)
    }
    if len(input.Grades) > 0 {
       query = query.Where("grade IN (?)", input.Grades)
    }
    if len(input.SubjectAreas) > 0 {
       query = query.Joins(`INNER JOIN subject_area_resource_mappings ON
             subject_area_resource_mappings.static_resource_id=static_resources.id             AND subject_area_resource_mappings.deleted_at IS NULL`).
          Where("subject_area_resource_mappings.subject_area_id IN (?)", input.SubjectAreas)
    }
    if len(input.TaskTypes) > 0 {
       query = query.Joins(`INNER JOIN task_type_resource_mappings ON
             task_type_resource_mappings.static_resource_id=static_resources.id             AND task_type_resource_mappings.deleted_at IS NULL`).
          Where("task_type_resource_mappings.task_type_id IN (?)", input.TaskTypes)
    }
    if len(input.Keywords) > 0 {
       query = query.Joins(`LEFT JOIN keywords_resource_mappings ON
             keywords_resource_mappings.static_resource_id=static_resources.id             AND keywords_resource_mappings.deleted_at IS NULL`).
          Joins(`LEFT JOIN keywords ON keywords.id=keywords_resource_mappings.keyword_id
             AND keywords.deleted_at IS NULL`)

       innerQuery := s.dbClient.WithContext(ctx)
       for index := range input.Keywords {
          innerQuery = innerQuery.Or("keywords.keyword ~* ? OR static_resources.title ~* ?",
             fmt.Sprintf(`.*%s.*`, input.Keywords[index]),
             fmt.Sprintf(`.*%s.*`, input.Keywords[index]))
       }
       query = query.Where(innerQuery)
    }
}

err := query.Joins("File", func(db *gorm.DB) *gorm.DB {
    return db.Select("id", "url", "thumbnail_url")
}).Find(&dbStaticResources, "static_resources.is_archived = false").Error
if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
    return nil, fmt.Errorf("services.GetAll: Error running query find: %w", err)
}
  </code></pre>
		<table data-id="test-types-table">
			<thead>
				<tr>
					<th></th>
					<th style="text-align: center">Unit</th>
					<th style="text-align: center">Integration</th>
					<th style="text-align: center">End-to-end</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th>Effort</th>
					<td
						class="fragment"
						data-fragment-index="0"
						style="text-align: center"
					>
						✅
					</td>
					<td
						class="fragment"
						data-fragment-index="0"
						style="text-align: center"
					>
						✅
					</td>
					<td
						class="fragment"
						data-fragment-index="1"
						style="text-align: center"
					>
						❌
					</td>
				</tr>
				<tr>
					<th>Value</th>
					<td
						class="fragment"
						data-fragment-index="4"
						style="text-align: center"
					>
						❌
					</td>
					<td
						class="fragment"
						data-fragment-index="3"
						style="text-align: center"
					>
						✅
					</td>
					<td
						class="fragment"
						data-fragment-index="2"
						style="text-align: center"
					>
						✅
					</td>
				</tr>
			</tbody>
		</table>
		<aside class="notes">
			<p>
				How about this example? We have some complicated logic here but all it
				does is determine what SQL we end up using to hit the database. First of
				all, what kind of tests are feasible for code like this? All of them, I
				can write any of these types to see that this works. We do have a lot of
				conditions that we may want to check all at once though. If we really
				want to test various conditions here, and if we think about the setup
				required...
			</p>
			<ul>
				<li>
					It won't be tough to set up some mocks for a unit test or seed some
					data for an integration test...
				</li>
				<li>
					But if we wanted to do something more end-to-end, then we could be
					looking at duplicating this test and all of its setup multiple times.
				</li>
				<li>
					But that's not to say we can't get the value for which we're looking
					if we go down that path.
				</li>
				<li>
					But we can get that value from integration tests that actually hit the
					database too.
				</li>
				<li>
					But I'm actually not sure that we get much value from a unit test
					here. If we set up a mock for our database, even if we verify the
					actual SQL, we get to return whatever data we say that database should
					return, and we have no idea if the SQL is correct. So for this
					example, an integration test feels like the right level.
				</li>
			</ul>
		</aside>
	</section>
	<section data-auto-animate>
		<h3>Which type to pick</h3>
		<pre><code data-trim data-noescape data-line-numbers class="language-ts">
// test that a user can record audio and submit a message
  </code></pre>
		<table data-id="test-types-table">
			<thead>
				<tr>
					<th></th>
					<th style="text-align: center">Unit</th>
					<th style="text-align: center">Integration</th>
					<th style="text-align: center">End-to-end</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th>Effort</th>
					<td
						class="fragment"
						data-fragment-index="0"
						style="text-align: center"
					>
						❌
					</td>
					<td
						class="fragment"
						data-fragment-index="1"
						style="text-align: center"
					>
						✅
					</td>
					<td
						class="fragment"
						data-fragment-index="2"
						style="text-align: center"
					>
						✅
					</td>
				</tr>
				<tr>
					<th>Value</th>
					<td
						class="fragment"
						data-fragment-index="4"
						style="text-align: center"
					>
						❌
					</td>
					<td
						class="fragment"
						data-fragment-index="4"
						style="text-align: center"
					>
						❌
					</td>
					<td
						class="fragment"
						data-fragment-index="3"
						style="text-align: center"
					>
						✅
					</td>
				</tr>
			</tbody>
		</table>
		<aside class="notes">
			<p>
				Now let's suppose that we have a need to test that a user can record
				audio and submit a message. We could write various integration tests but
				how can we prove that one leads to another and everything feeds into one
				another?
			</p>
			<ul>
				<li>
					I can think of this in terms of the human behavior of what they want
					to perform and what they hope to see, but it would require so many
					interconnected units, there is basically no way to unit test this. We
					could unit test various points along the way but that doesn't address
					the goal for this test we want to write.
				</li>
				<li>
					We could maybe put something together with several key integration
					tests that hit APIs that we know it will require.
				</li>
				<li>
					And we could also write a full end-to-end test of the entire process
					that a user experiences.
				</li>
				<li>
					Which honestly is fitting our need. If we had concerns about just the
					upload feature or just the displaying of recordings feature, we could
					do those in integration tests...
				</li>
				<li>
					But for this, we decide that the value we hope to achieve is that the
					user not only will eventually see this info but that they instantly
					see it as soon as they navigate to that page. To truly test that full
					user experience, which we do feel is a critical need for our
					application, we decide that, despite the longer runtime and trickier
					maintainability of end-to-end tests, that that is the right level for
					this.
				</li>
			</ul>
		</aside>
	</section>
</section>
<section data-auto-animate data-auto-animate-restart>
	<section data-auto-animate>
		<h2>How to get started</h2>
		<h3>TDD</h3>
		<h3>Leave better than you found it</h3>
		<h3>E2E</h3>
	</section>
	<section data-auto-animate>
		<h2>How to get started</h2>
		<h3>TDD</h3>
		<p>TDD - start new unit tests with</p>
		<aside class="notes">Something here</aside>
	</section>
	<section data-auto-animate>
		<h2>How to get started</h2>
		<h3>Leave better than you found it</h3>
		<p>scary area you're afraid to make changes in? start by making a test</p>
		<aside class="notes">Something here</aside>
	</section>
	<section data-auto-animate>
		<h2>How to get started</h2>
		<h3>E2E</h3>
		<p>
			code all mixed up so it's tough to write simple unit or integration tests?
			maybe starting with an end-to-end would be good
		</p>
		<p>
			maybe that really is the lowest level that gives you value until you can
			rearchitect the code
		</p>
		<aside class="notes">Something here</aside>
	</section>
</section>
<section data-auto-animate data-auto-animate-restart>
	<h2>remember</h2>
	<ul>
		<li>start small and get it in the CI/CD pipelines</li>
		<li>make a commitment to add to test suites over time</li>
	</ul>
</section>
<section data-auto-animate data-auto-animate-restart>
	<h2>Delete tests that no longer serve you</h2>
</section>
<section data-auto-animate data-auto-animate-restart>
	<h2>Refactoring means not changing what happens</h2>
</section>
<section data-auto-animate data-auto-animate-restart>
	<h2>Linters?</h2>
</section>
<section data-auto-animate data-auto-animate-restart>
	<h2>test behavior, not implementation</h2>
</section>
<section>
	<h2>You have to start somewhere</h2>
	<p>Test the change you want to see in the world</p>
	<p class="fragment">Be the change you want to see in the world</p>
	<aside class="notes">
		<p>
			Ideally, we should be testing the changes that we want to make in the app.
			That can be tough when no pattern exists yet. And it's not always a good
			time to make that investment into creating tests where there aren't any.
			But if it's something you're passionate about...
		</p>
		<ul>
			<li>
				Maybe it's up to you to <strong>be</strong> the change you want to see
				in your codebase. Stand up for it and champion the cause. I'll share
				some stories of how I and my team did just that on an application that
				was originally written by a third party and did not have much test
				coverage.
			</li>
		</ul>
	</aside>
</section>
<section>
	<section data-auto-animate>
		<h2>Adding back-end tests</h2>
		<ul>
			<li class="fragment">
				The more we prepare data in the backend for how the frontend will use
				it, the more we can rely on quick back-end unit tests.
			</li>
			<li class="fragment">
				Difference between a unit and integration test may just be whether an
				interface is <strong>mocked</strong> or if its
				<strong>implementation</strong> is actually used.
			</li>
		</ul>
		<img src="/img/testify.png" alt="Testify logo" class="fragment" />
		<aside class="notes">
			<p>
				One nice thing about this project is that there were back-end tests,
				just not a lot of them. But at least it gave us a starting point.
			</p>
			<ul>
				<li>
					Something to consider in general with back-end development is that, if
					you know how the front-end will interact with this data, and you can
					do all of your in-memory modifications in the back-end, then you can
					unit test those modifications in what will generally be your fastest
					tests to run of all.
				</li>
				<li>
					There are several libraries out there for all kinds of languages, and
					the tool is not going to be what determines if it is unit or
					integration, it is whether dependencies behind interfaces are mocked
					or if we actually allow the code to hit a test database or a test API.
				</li>
				<li>
					Our back-end is Go, and the project used Testify, which we continue to
					use; it is a great library. On .NET projects, I have used NUnit and
					xUnit. There are many options for your needs.
				</li>
			</ul>
		</aside>
	</section>
	<section data-auto-animate>
		<h2>Adding back-end tests</h2>
		<pre><code data-trim data-line-numbers data-id="endToEndSample" class="language-go">
func TestMyFunction(t *testing.T) {
	var myTests = []struct {
		inputValue     int
		expectedOutput string
	}{
		{inputValue: 2, expectedOutput: "critical"},
		{inputValue: 3, expectedOutput: "low"},
		{inputValue: 10, expectedOutput: "high"},
	}
	for _, tt := range myTests {
		actualOutput, actualError := MyFunction(tt.inputValue)
		require.Equal(t, tt.expectedOutput, actualOutput)
	}
}
		</code></pre>
		<aside class="notes">
			Here is a super simplified example of a unit test we can have. Let's say
			that we are tracking some sort of numerical data, and we have discrete
			levels at which we need to display a text state. We can set up many test
			cases and have them quickly check this business logic in a function that
			only has that one purpose, and then we can trust that value when it get
			passed back to the front-end.
		</aside>
	</section>
</section>
<section>
	<section data-auto-animate>
		<h2>Adding end-to-end tests</h2>
		<ul>
			<li class="fragment">
				Highest and smallest on both the pyramid and the trophy
			</li>
			<li class="fragment">
				That doesn't mean to not write them; they can be very helpful
			</li>
		</ul>
		<img
			src="/img/playwright.svg"
			alt="Playwright logo"
			height="200px"
			class="fragment"
		/>
		<aside class="notes">
			<p>
				On my team, we inherited an application that had been developed by a
				third party, and testing was not in a great state. There were a few unit
				tests, no integration tests, and the only end-to-end tests that existed
				hadn't been run in a year, so many just failed now.
			</p>
			<ul>
				<li>
					End-to-end tests are on the top of the pyramid, and it is generally
					agreed that they take the longest to run, and it can hurt to see them
					fail.
				</li>
				<li>
					But that does not mean to avoid them. They are a powerful tool, and
					end-to-end test libraries have only improved with time. Many teams
					have success with libraries like Selenium and Cypress...
				</li>
				<li>
					But we chose Playwright as our tool of choice. It runs very fast, it
					comes with support for different browsers out of the box, and there is
					a very strong community behind it.
				</li>
			</ul>
		</aside>
	</section>
	<section data-auto-animate>
		<h2>Adding end-to-end tests</h2>
		<pre><code data-trim data-line-numbers="|7,11-13|20|" data-id="endToEndSample" class="language-ts">
test('teacher can create new assignment',
		async ({ page }) => {
	await this.page.goto('/login');
	await this.page
      .locator('.MuiCircularProgress-svg')
      .waitFor({ state: 'hidden' });
	await this.page.getByRole('combobox').fill(districts.newDistrict.districtName);
	await this.page
		.getByRole('option', { name: district, exact: true })
		.click();
	await this.page.getByRole('textbox', { name: 'Username' }).fill(users.teacher.email);
	await this.page.getByRole('textbox', { name: 'Password' }).fill(process.env.USER_PASSWORD!);
	await this.page.getByRole('button', { name: 'Login' }).click();
	await expect(this.page.getByLabel('account of current user')).toContainText(
		`${users.superAdmin.firstName} ${users.superAdmin.lastName}`,
	);
	await this.page.getByRole('button', { name: 'create Assignment' }).click();
	await this.page
		.getByRole('main')
		.getByRole('button', { name: '​', exact: true })
		.click();
	await this.page.getByText(className).click();
	// ...
});
  </code></pre>
		<p>We started with Playwright Codegen</p>
		<aside class="notes">
			<p>
				Starting is actually very easy. Once you have set up a Playwright
				project, while there is certainly a learning curve to understand how to
				best use it, it is possible to dive right into creating tests using
				their test code generation tool. It will open up a browser and record
				all actions you take and generate a test for you.
			</p>
			<ul>
				<li>
					As you can see, it even tries to use semantic information from your
					page to determine reliable locators.
				</li>
				<li>
					But you can still get weird results if your app is not accessible. In
					this case, I am trying to click on what I think is a drop-down select
					element, but it is actually constructed of other components, where the
					drop-down arrow is a button that has no text, so we look for a button
					with absolutely no text. Just looking at this should be a red flag
					because, if our test can't target anything more specific about this
					button and its perceived role, then what hope does someone using a
					screen reader have? But this is the best it can do for now, so we make
					note of that for our accessibility audit we aim to have.
				</li>
				<li>
					But at least we have a test now. But it's not very readable, is it? It
					could be much, much worse, but if someone wanted to know, what is the
					purpose of this test, it might take a while to truly understand.
				</li>
			</ul>
		</aside>
	</section>
	<section data-auto-animate>
		<h2>Adding end-to-end tests</h2>
		<pre><code data-trim data-line-numbers="|3-7" data-id="endToEndSample" class="language-ts">
test('teacher can create new assignment',
		async ({ loginPage, header, teacherPage }) => {
	await loginPage.login(
		districts.newDistrict.districtName,
		users.teacher.email,
		process.env.USER_PASSWORD!,
	);
	await expect(header.usernameButton).toContainText(
		`${users.teacher.firstName} ${users.teacher.lastName}`,
	);
	await teacherPage.createNewAssignment();
	await teacherPage.chooseClass(classes.newClass.className);
	// ...
});
  </code></pre>
		<p>We refactored with Page Object Model</p>
		<aside class="notes">
			<p>
				So we then took some time and refactored our test code to using the Page
				Object Model pattern. We are performing the exact same operations here
				as before, but everything related to logging in can be abstracted into a
				function, and the idea of clicking a button called Create to create an
				assignment could benefit from some readability. It's in a better
				direction now. Page Object Model always feels a little bit controversial
				to me though, because if we just abstract every single line, then we are
				hiding the true functionality, and it's easy now to change what these
				functions do without remembering to change their names. But I still
				ultimately enjoy this pattern because it does increase readability, and
				we can understand the intent of a test much easier.
			</p>
			<ul>
				<li>
					One of our next big changes to the app was around the login process.
					We got about a dozen tests up and running, and every single one of
					them needed to go to a brand-new session and login as a user all over
					again. It can be very time intensive, not to mention it looks like
					suspicious behavior.
				</li>
			</ul>
		</aside>
	</section>
	<section data-auto-animate>
		<h2>Adding end-to-end tests</h2>
		<pre><code data-trim data-line-numbers="|1" data-id="endToEndSample" class="language-ts">
test.use({ storageState: StorageStates.teacher });
test('teacher can create new assignment',
		async ({ teacherPage }) => {
	await teacherPage.page.goto('/');
	await teacherPage.createNewAssignment();
	await teacherPage.chooseClass(classes.newClass.className);
	// ...
});
  	</code></pre>
		<p>Took advantage of Storage State</p>
		<aside class="notes">
			<p>
				So we took advantage of the storage state feature. We have a few users
				we may need to log in as for various tests, so before any actual tests
				get run, we log in as each of these users and save the state of the
				browser context.
			</p>
			<ul>
				<li>
					Then, all of our tests simply need to call out which state they need,
					and the test starts with them already authenticated. This saves us a
					lot of time when running our tests.
				</li>
			</ul>
		</aside>
	</section>
</section>
<section>
	<section data-auto-animate>
		<h2>Adding front-end tests</h2>
		<ul>
			<li class="fragment" data-fragment-index="0">
				Many libraries exist that help with both unit tests and integration
				tests.
			</li>
			<li class="fragment" data-fragment-index="1">
				Some front-end testing may be considered "component testing".
			</li>
		</ul>
		<div style="display: flex; align-items: center; justify-content: center">
			<img
				src="/img/vite.svg"
				alt="Vite logo"
				height="200px"
				class="fragment"
				data-fragment-index="2"
			/>
			<span class="fragment" data-fragment-index="3">➡️</span>
			<img
				src="/img/vitest.svg"
				alt="Vitest logo"
				height="200px"
				class="fragment"
				data-fragment-index="3"
			/>
		</div>
		<aside class="notes">
			<p>
				Now that we covered the critical paths with end-to-end testing, our
				attention turned to the fact that we had no testing in our front-end.
			</p>
			<ul>
				<li>
					There are many libraries for front-end testing in web development, and
					many of them can be used for both unit and integration testing.
				</li>
				<li>
					There is also a lot of support for component testing. As for what
					component testing is, it depends on who you ask. In my experience, if
					you were to ask me, I still think of my tests as being unit or
					integration based on whether I am testing a very small amount of
					isolated behavior or if I am testing the integration between different
					parts of my code or the integration of my code with a database or API
					layer.
				</li>
				<li>
					We use Vite as the build engine for our React app. There are several
					libraries we could have chosen...
				</li>
				<li>
					But ultimately picked Vitest. It works much like Jest but has a
					similar build configuration to Vite, so they play nicely together, and
					it seemed like a good choice for a new library for this project.
				</li>
			</ul>
		</aside>
	</section>
	<section data-auto-animate>
		<h2>Adding front-end tests</h2>
		<pre><code data-trim data-line-numbers="|19-25,27|12,15,26">
const keywords: MockedResponse&lt;GetKeywordsQuery> = {
	request: {
		query: GetKeywordsDocument,
	},
	result: {
		data: {
			keyword: [{ id: '1234', keyword: 'hello' }],
		},
	},
};
it('should add new keyword', async () => {
	const onChange = vi.fn();
	render(
		&lt;MockedProvider mocks={[keywords]}>
			&lt;AddKeywordTags onChange={onChange} />
		&lt;/MockedProvider>
	);

	const combobox = screen.getByRole('combobox');
	await waitFor(() => expect(combobox).not.toBeDisabled(), {
		timeout: 500,
	});
	await userEvent.type(combobox, 'world');
	expect(screen.getByDisplayValue('world')).toBeInTheDocument();
	await userEvent.keyboard('{enter}');
	expect(onChange).not.toHaveBeenCalled();
	expect(screen.getByText('Add a new keyword')).toBeVisible();
});
  </code></pre>
		<aside class="notes">
			<p>
				On my current team, we inherited a project that had all kinds of
				front-end components but not a single front-end test. It was something
				that always bothered us, and it did not make sense for us to go in and
				start adding hundreds of tests when we could be working on feature work.
				But when we started tackling something that behaved a bit strange in the
				front-end, it was our opportunity.
			</p>
			<ul>
				<li>
					Notice that we are trying to keep this behavior-focused. We want to
					think of this less as what data outputs do we want for given data
					inputs, but rather what result should a user see when they interact in
					certain ways.
				</li>
				<li>
					Sometimes, though, it can be hard to truly get out of implementation
					details. This here is not ideal; we are mocking a function and asking
					about whether it got called. The reason for this is that the way this
					component had been written, this would be incorporated on a form, and
					it would manage all change events and form states. We could do this
					another way if we wanted to test the entire form on which this
					component is used, but that is more than we wanted to test for this
					story.
				</li>
			</ul>
		</aside>
	</section>
</section>
<section>
	<h1>Thank you!</h1>
	<div
		style="display: grid; grid-template-columns: 2fr 1fr; align-items: center"
	>
		<p>Chris Stone<br /><a href="/">https://chrisstone.dev</a></p>
		<a href="/deploy-without-fear"
			><img
				src="/img/deploy-without-fear-2d-code.svg"
				alt="QR code for talk notes and slides"
		/></a>
	</div>
	<aside class="notes">
		And that is about it! There is so much more we could dive into on this
		subject, but I hope that I helped you all see how valuable automated tests
		can be and to start adding some new tests so you can get over any fears you
		have of deploying and start being excited to continuously integrate! Thanks
		everyone.
	</aside>
</section>
